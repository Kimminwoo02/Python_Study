"""
문자열 메소드 종류

"""

'''
Python은 문자열(str)을 처리하기 위해 많은 메소드를 제공해준다.
문자열 메소드는 다양한 분야에서 이용하기 때문에 여러 번 연습해두는게 좋다!

'''
'''
1. format()메소드
- format 메소드는 print함수 사용할 때 사용한다.

format 정렬 옵션
1-1. <: 지정된 공간 내에서 '왼쪽' 정렬한다.
1-2. >: 지정된 공간 내에서 '오른쪽' 정렬한다.
1-3. ^: 지정된 공간 내에서 '가운데' 정렬한다.
'''

# 예시
print("10자리 폭 왼쪽 정렬'{:<10d}'".format(123))
print("10자리 폭 오른쪽 정렬'{:>10d}'".format(123)) # : 는 내가 무언갈 쓰겠다라는 의미 10d는 10개의 공백을 만든다.
print("10자리 폭 중앙 정렬'{:^10d}'".format(123))

# *로 채우기

print("10자리 폭 왼쪽 정렬'{:*<10d}'".format(123))
print("10자리 폭 오른쪽 정렬'{:*>10d}'".format(123))
print("10자리 폭 가운데 정렬'{:*^10d}'".format(123))

print(f'') # 이 형태를 S-format 이라고 한다.
print(f"10자리 폭 왼쪽 정렬'{123:<10}'") #이렇게 변경할 수 있다. 이게 더 편하다!
print(f"10자리 폭 오른쪽 정렬'{123:>10}'")
print(f"10자리 폭 오른쪽 정렬'{123:*^10}'")


print(f"10자리 폭 오른쪽 정렬'{123:*>10}'")
print(f"10자리 폭 왼쪽 정렬'{123:*<10}'")
print(f"10자리 폭 가운데 정렬'{123:*^10}'")

# '<','>','^'는 정렬 옵션이고, 10d는 10자리 폭을 의미한다.
# 정렬 옵션 앞에 채움 문자를 지정하고 공백 대신 채움 문자가 빈자리를 채운다.
#참고로 '123' = ['1','2','3']


'''
2. count 메소드
- 문자열 내부에 포함된 특정 문자열의 개수를 반환하는 메소드!
'''
#
# s = '내가 그린 기린 그림은 목 긴 기린 그림이고, 네가 그린 기린 그림은 목 짧은 기린 그림이다.'
#
# print(s.count('기린'))

# 인덱스를 지정해서 검색 범위 지정 가능하다(음수도 가능)
#예시!

s= 'best of the best'
# b e s t'  'o f ' 't h e'  'b e s t
# 0 1 2 3 4 5  6  7 8 9 101112 13...
#-12 -11 -10- 9 ...               -1

print(s.count('best',5)) # 출력 결과는 1인데 그 이유는 뒤의 5가 인덱스 5 이후로 부터 best를 찾아줘서 그렇다.
print(s.count('best',-7)) # 이것 역시 위와 같은 의미이다.

'''
3.find 메소드
찾고자 하는 문자열이 있으면 그 문자열이 '처음 나오는 위치' '인덱스'를 반환해준다.

'''
s = 'apple'
# 있는 단어
print(s.find('p')) # 결과값이 1이다. 인덱스를 반환해주는거다.


#없는 단어
print(s.find('z')) # 결과값이 -1이다. 없는 단어는 -1값을 고정적으로 반환해준다.

# count 메소드와 동일하게 인덱스를 이용해서 검색할 범위를 지정할 수 있다.
# 생략하면 처음 위치부터 찾고 입력하면 해당 입력한 인덱스 부터 검색을 실행함.

# 예시
s = 'best of the best'
# 처음 시작( 생략)
print(s.find('best')) # 결과값으로 0을 반환 맨 앞에 있는 인덱스이므로
print(s.find('best',5)) # 결과 값으로 12가 나오는데 인덱스 5부터 best가 제일 먼저 나오는 인덱스를 반환

# find 메소드와 찾는 방향이 다른 rfind()메소드가 있다
# rfind = right + find

print(s.rfind('best')) # 뒤에서 부터 검색한 거다!

'''
4. index 메소드
 인덱스 메소드는 find 메소드와 같은 역할을 수행하고 사용방법 또한 동일하다.
 차이점은 찾는 문자열이 없을 때 발생

find 쓰면 되는데 굳이 index를 사용하는 이유?
-> 예외처리를 위해 사용한다.
'''

s= 'apple'
print(s.index('a'))
#print(s.index('z')) # 실행시 에러가 난다!

'''
5. upper(), lower(), Capitalize()
 - 영문의 대소문자를 변환해주는 메소드
 
5-1 .upper : 입력이 된 문자열을 모두 대문자로 변환된 결과를 반환!
5-2 .lower : 입력이 된 문자열을 모두 소문자로 변환된 결과를 반환!
5-3 .capitalize : 입력이 된 문자열을 첫 글자는 대문자로 변환하고 나머지는 소문자로 변환!
'''

s ="BEST of the best"
print(s.upper()) # 결과 BEST OF THE BEST
print(s.lower()) # 결과 best of the best
print(s.capitalize()) #결과 Best of the best


# 파이썬의 영문은 대소문자를 구분하기 때문에
# 모두 같은 단어로 인식하려면 대소문자 변환 메소드 처리 후
# 비교할려는 모든 단어를 통일시킨 뒤 처리!
a = 'APPLE'
s = 'apple'
if s.lower() == 'apple':
    print('돈을 내시오!')

'''
6.join 메소드
조인 메소드는 인수로 전달한 반복가능객체(문자열, 리스트 등)의 각 요소 사이에 
문자열을 포함시켜 새로운 문자열을 만들고 그 결과를 반환합니다.

'''
dates = ['2021','07','17']
#2021-07-17 이렇게 바꾸려면?!
print(f"{'-'.join((dates))}")

print('-'.join('python'))

print('-'.join(['a','b','c','d','e','f']))
print(''.join(['a','b','c','d','e','f']))# 공백도 가능

#6.3 딕셔너리와 join(key 값을 이용)
print('@'.join({'a':'apple','b':'banana'})) # 키값들 사이사이에 @ 들어간다 즉 a@b

'''
7. split() 메소드
하나의 문자열을 여러 개의 문자열로 분리해서
저장한 리스트를 반환하는 메소드!

기본적으로 공백 문자를 기준으로 분리.
* 사용자가 입력한 문자열 기준으로도 분리 가능
'''
# 공백 기준 분리 (기본 값)
s = 'Life is too short'
print(s.split()) # 결과로 ['life','is','too',short']가 출력된다!

# 특정 문자를 기준으로 분리

s = '010-1234-5678'
print(s.split('-'))

# CSV( comma Seperated Value) : ',' 로 구분된 데이터 처리
s = '제임스,25,남,서울'
print(s.split(','))

'''
8. replace() 메소드 
 replace() 메소드는 '문자열'의 일부 문자열 을 다른 문자열 로 바꾼 결과를 반환!

'''

s = 'Life is too short'

print(s.replace('short','long')) # 처음 인수 가 기본값, 그 다음 인수가 바뀔 값이다! short -> long

#특정 문자열을 제거 할때 많이 사용
s = '010-1234-5678'
print(s.replace('-','')) # 01012345678

'''
9.lstrip,rstrip,strip 메소드

문자열의 양끝에 있는 불필요한 문자열을 제거하는 메소드!
불필요한 문자열 기본 =' '
( 중간에 포함된 문자열은 제거 X )
'''
# 9-1 lstrip() left + strip : 왼쪽 끝에 있는 불필요한 문자열을 제거한 결과 반환

s = '          apple'
print(s.lstrip()) # 앞에 있는 공백 다 날라간다!


# 9-2 rstrip () = right + strip : 오른쪽 끝에 있는 불필요한 문자열을 제거한 결과를 반환!
s = 'apple       '
print(s.rstrip()) # 오른쪽에 있는 공백을 모두 제거!

# 9 - 3 strip : 양쪽 끝에 있는 불필요한 문자열을 제거한 결과를 반환!
s = '       apple          '
print(s.strip()) # 양쪽에 있는 공백을 모두 제거!

# 불필요한 문자열 제거
s = '<head'
print(s.strip('<')) # head 만 나온다!

'''
책 예제 ) 다음은 주민등록번호에서 생년월일 6자리 추출하는 프로그램입니다.
사용자로부터 하이픈- 을 포함한 전체 주민등록번호를 입력받아 처리하는데,
만약 하이픈 의 위치가 올바르지 않다면 오류 메세지를 출력하고 다시 입력받도록
처리해보자

출력 : 하이픈을 포함하여 전체 주민번호를 입력하세요
하이픈의 위치가 잘못되었습니다.
'''
'''
while True:
    p = input('하이픈을 포함하여 주민번호를 입력하세요:')
    if p.find('-') == - 1:
        print('하이픈을 입력해주세요.')
        continue
    elif p.find('-') != 6:
        print('하이픈의 위치가 잘못되었습니다.')
        continue
    birthday = p.split('-')[0]
    print(f'생년월일은{birthday} 입니다.')
    break

'''
'''
예제: 사용자가 입력한 문자에 조건에 맞는 문자가 포함되어 있으면 
*로 바꾸는 프로그램을 만드세요.

특정 문자 = 'ㅁ','a','b','c','dd','db'
'''

i = input('문자열을 입력해주세요:')
special = ['ㅁ','a','b','c','dd','db']

for a in special:
    i = i.replace(a,'*')
print(i)

'''
다음은 주민등록번호에서 뒷자리 6자리를 암호화 하는 프로그램입니다.
하이픈 뒷 자리를 가려주게 처리해보자
950701-*******
'''

while True:
    p = input('하이픈을 포함하여 주민번호를 입력하세요:')
    if p.find('-') == - 1:
        print('하이픈을 입력해주세요.')
        continue
    elif p.find('-') != 6:
        print('하이픈의 위치가 잘못되었습니다.')
        continue
    splits= p.split('-')
    data = ''
    birthday=splits[0]
    for i in splits[1]:
        data += '*'
    print(f'{birthday}-{data}')
    break

